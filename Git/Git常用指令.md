# Git 常用指令

## 克隆现有库

	$ git clone [url] [project name]

在当前目录下克隆服务器上的项目，默认创建同名文件夹，也可以改成自己的名字；url 支持 https:// 协议、git:// 协议及 SSH 传输协议。

## 检查当前文件状态

	$ git status
	$ git status -s		// 状态简览

## 跟踪新文件／暂存已修改文件

	$ git add [path/file]

* 如果参数为文件夹，则会自动递归该文件夹下面的子文件夹，所以常用 `git add .` 命令；
* 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等；
* 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。

## 忽略文件
我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式，或者把总结好的 .gitignore 文件放入项目的根目录下。

要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。

## 查看已暂存和未暂存的修改

如果 git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。

	$ git diff
	
若要查看已暂存的将要添加到下次提交里的内容，可以用 `git diff --cached/--staged` 命令。

## 提交更新

现在的暂存区域已经准备妥当可以提交了。 在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit：

	$ git commit
	
该命令起会拉起 Vim 编辑器来提示本次提交的信息，加入 `-v` 选项会把你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。

另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示：

	$ git commit -m "commit info"

## 跳过使用暂存区域

在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：

	$ git commit -a -m 'added new benchmarks'
	
最好还是分开单独使用，这样比较清晰些，不容易出错。

## 查看提交历史

	$ git log

一个常用的选项是 -p，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交：

	$ git log -p -2

该选项除了显示基本信息之外，还在附带了每次 commit 的变化。 当进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化的时候，这个参数就非常有用了。 你也可以为 git log 附带一系列的总结性选项。 比如说，如果你想看到每次提交的简略的统计信息，你可以使用 --stat 选项：

	$ git log --stat

除此之外，`git log` 命令还有很多其他有用的参数，具体请自行查看帮助文档 `git log --help`

## 撤消对文件的修改

	$ git checkout -- <file>

你需要知道 git checkout -- [file] 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。

## 查看远程仓库

	$ git remote

你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。

	$ git remote -v

如果你的远程仓库不止一个，该命令会将它们全部列出，这样我们可以轻松拉取其中任何一个用户的贡献。

## 从远程仓库中抓取与拉取

	$ git fetch [remote-name]

这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。

必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。

如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。

## 推送到远程仓库

	$ git push [remote-name] [branch-name]
	
只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。

## 查看远程仓库

	$ git remote show [remote-name]
	
列出的信息非常有用，包括仓库的 url ， 目前所在分支，共有多少分支等等。

## 标签 Tag

Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。

### 列出标签

	$ git tag

你也可以使用特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：

	$ git tag -l 'v1.8.5*'

### 创建标签

Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。

#### 附注标签

在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 tag 命令时指定 -a 选项：

	$ git tag -a v1.4 -m 'my version 1.4'
	
-m 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。

通过使用 git show 命令可以看到标签信息与对应的提交信息：

	$ git show v1.4

输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。

#### 轻量标签

创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：

	$ git tag v1.4.1
	
#### 后期打标签

你也可以对过去的提交打标签。 假设提交历史是这样的：

	$ git log --pretty=oneline
	15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'
	a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
	0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
	6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'
	0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
	4682c3261057305bdd616e23b64b0857d832627b added a todo file
	166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
	9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
	964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
	8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme

现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）:

	$ git tag -a v1.2 9fceb02

#### 共享标签

默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 `git push origin [tagname]`。

	$ git push origin v1.5
	
如果想要一次性推送很多标签，也可以使用带有 `--tags` 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。

	$ git push origin --tags

## 分支

### 分支创建

Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：

	$ git branch [branch name]
	
那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。

### 分支切换

要切换到一个已存在的分支，你需要使用 git checkout 命令。 我们现在切换到新创建的 testing 分支去：

	$ git checkout [branch name]
	
> **分支切换会改变你工作目录中的文件**
> 
> 在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。

**你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。**

你可以使用 git merge 命令来达到上述目的：

	$ git checkout master
	$ git merge [branch name]
	Updating f42c576..3a0874c
	Fast-forward
	 index.html | 2 ++
	 1 file changed, 2 insertions(+)

在合并的时候，你应该注意到了"快进（fast-forward）"这个词。 由于当前 master 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。

